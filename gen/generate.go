package main

import (
	. "github.com/CherkashinEvgeny/gogen"
	tgen "github.com/CherkashinEvgeny/gogen/types"
	"go/types"
	"strconv"
)

const copyright = "// Code generated by github.com/CherkashinEvgeny/goaspect DO NOT EDIT."

type config struct {
	DstPkgName   string
	SrcPkg       *types.Package
	ImportSrcPkg bool
	Aspects      []aspectConfig
}

type aspectConfig struct {
	IfaceName  string
	Iface      *types.Interface
	AspectName string
}

func generate(cfg config) (code string, err error) {
	imports := make([]Code, 0)
	aspects := make([]Code, 0, len(cfg.Aspects))
	for _, aspectCfg := range cfg.Aspects {
		imports = append(imports, tgen.InterfaceImports(aspectCfg.Iface)...)
		aspects = append(aspects, generateInterfaceAspect(cfg.SrcPkg, aspectCfg))
	}
	pkg := Pkg(copyright, cfg.DstPkgName, Imports(imports...), Blocks(aspects...))
	return Stringify(pkg), nil
}

func generateInterfaceAspect(pkg *types.Package, aspectCfg aspectConfig) Code {
	reflectTypeId := aspectCfg.IfaceName + "Type"
	ifaceType := Named(pkg.Path(), aspectCfg.IfaceName)
	reflectType := Join(
		"",
		Raw("var "),
		Id(reflectTypeId),
		Raw(" = "),
		Raw("reflect.TypeOf((*"),
		ifaceType,
		Raw(")(nil)).Elem()"),
	)
	aspectType := Type(aspectCfg.AspectName, Struct(Fields(
		FieldDef("impl", ifaceType),
		FieldDef("container", Ptr(Named("github.com/CherkashinEvgeny/goaspect", "Container"))),
	)))
	aspectMethods := generateAspectMethods(reflectTypeId, Id(aspectCfg.AspectName), aspectCfg.Iface)
	return Blocks(
		reflectType,
		aspectType,
		aspectMethods,
	)
}

func generateAspectMethods(reflectTypeId string, receiver Code, iface *types.Interface) Code {
	methods := make([]Code, 0)
	n := iface.NumEmbeddeds()
	for i := 0; i < n; i++ {
		embedded := iface.EmbeddedType(i)
		underlying := embedded.Underlying()
		embeddedIface, ok := underlying.(*types.Interface)
		if !ok {
			continue
		}
		methods = append(methods, generateAspectMethods(reflectTypeId, receiver, embeddedIface))
	}
	n = iface.NumMethods()
	for i := 0; i < n; i++ {
		method := iface.Method(i)
		methodType := method.Type()
		sign, ok := methodType.(*types.Signature)
		if !ok {
			continue
		}
		methods = append(methods, generateAspectMethod(reflectTypeId, receiver, method.Name(), sign))
	}
	return Blocks(methods...)
}

func generateAspectMethod(reflectTypeId string, receiver Code, name string, sign *types.Signature) Code {
	reflectMethodId := reflectTypeId + "Method" + name
	methodType := Join("",
		Raw("var "), Id(reflectMethodId), Raw(", _"),
		Raw(" = "),
		Id(reflectTypeId), Raw(".MethodByName("), Val(name), Raw(")"),
	)
	busyNames := map[string]struct{}{
		"a":             {},
		"aspect":        {},
		reflectTypeId:   {},
		reflectMethodId: {},
	}
	inParams := generateInParamNames(sign.Params(), busyNames)
	outParams := generateOutParamNames(sign.Results(), busyNames)
	method := Method(
		Param("a", receiver, false),
		name,
		generateAspectMethodSignature(sign, inParams, outParams),
		generateAspectMethodBody(reflectTypeId, reflectMethodId, name, sign, inParams, outParams),
	)
	return Blocks(
		methodType,
		method,
	)
}

func generateInParamNames(t *types.Tuple, busyNames map[string]struct{}) []string {
	return generateParamNames(t, "arg", busyNames)
}

func generateOutParamNames(t *types.Tuple, busyNames map[string]struct{}) []string {
	return generateParamNames(t, "res", busyNames)
}

func generateParamNames(t *types.Tuple, prefix string, busyNames map[string]struct{}) []string {
	n := t.Len()
	names := make([]string, 0, n)
	for i := 0; i < n; i++ {
		param := t.At(i)
		name := param.Name()
		if name == "" {
			name = prefix + strconv.Itoa(i)
		}
		name = generateName(param.Name(), busyNames)
		names = append(names, name)
	}
	return names
}

func generateAspectMethodSignature(
	sign *types.Signature,
	inParams []string,
	outParams []string,
) Code {
	params := sign.Params()
	n := params.Len()
	in := make([]Code, 0, n)
	if sign.Variadic() {
		n--
	}
	for i := 0; i < n; i++ {
		param := params.At(i)
		in = append(in, Param(inParams[i], tgen.Type(param.Type()), false))
	}
	if sign.Variadic() {
		param := params.At(n)
		in = append(in, Param(inParams[n], tgen.Type(param.Type()), true))
	}

	params = sign.Results()
	n = params.Len()
	out := make([]Code, 0, n)
	for i := 0; i < n; i++ {
		param := params.At(i)
		out = append(out, Param(outParams[i], tgen.Type(param.Type()), false))
	}
	return Sign(In(in...), Out(out...))
}

func generateAspectMethodBody(
	reflectTypeId string,
	reflectMethodId string,
	name string,
	sign *types.Signature,
	inParams []string,
	outParams []string,
) Code {
	aspect := Join("", Raw("aspect := a.container.Aspect("), Ids(Id(reflectTypeId), Id(reflectMethodId)), Raw(")"))
	inParamsValues := make([]Code, 0, len(inParams))
	for i, inParam := range inParams {
		param := sign.Params().At(i)
		inParamsValues = append(inParamsValues, Inst(
			Named("github.com/CherkashinEvgeny/goaspect", "Param"),
			Fields(
				Field("Name", Val(param.Name())),
				Field("Value", Id(inParam)),
			),
		))
	}
	inParamIds := make([]Code, 0, len(inParams))
	for _, inParam := range inParams {
		inParamIds = append(inParamIds, Id(inParam))
	}
	outParamIds := make([]Code, 0, len(outParams))
	for _, outParam := range outParams {
		outParamIds = append(outParamIds, Id(outParam))
	}
	var implCall Code
	if len(outParamIds) == 0 {
		implCall = Join("", Raw("a.impl."), Id(name), Raw("("), Ids(inParamIds...), Raw(")"))
	} else {
		implCall = Join("", Ids(outParamIds...), Raw(" := "), Raw("a.impl."), Id(name), Raw("("), Ids(inParamIds...), Raw(")"))
	}
	before := Join("", Raw("aspect.Before("), Vals(inParamsValues...), Raw(")"))
	outParamsValues := make([]Code, 0, len(outParams))
	for i, outParam := range outParams {
		param := sign.Results().At(i)
		outParamsValues = append(outParamsValues, Inst(
			Named("github.com/CherkashinEvgeny/goaspect", "Param"),
			Fields(
				Field("Name", Val(param.Name())),
				Field("Value", Id(outParam)),
			),
		))
	}
	after := Join("", Raw("aspect.After("), Vals(outParamsValues...), Raw(")"))
	if len(outParamIds) == 0 {
		return Lines(
			aspect,
			before,
			implCall,
			after,
		)
	}
	returnResult := Join("", Raw("return "), Ids(outParamIds...))
	return Lines(
		aspect,
		before,
		implCall,
		after,
		returnResult,
	)
}

func generateName(preferredName string, busyNames map[string]struct{}) string {
	name := preferredName
	counter := 1
	for {
		_, found := busyNames[name]
		if !found {
			break
		}
		counter++
		name = preferredName + strconv.Itoa(counter)
	}
	busyNames[name] = struct{}{}
	return name
}
